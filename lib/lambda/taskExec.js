/* eslint-disable no-underscore-dangle */

const fs = require('fs')
const os = require('os')
const path = require('path')

const def = require('./taskDef')

const impl = run => ({
  /**
   * Run a load test given an Artillery script and report the results
   * @param timeNow The time this task invocation began (serves as an id for the function)
   * @param script The artillery script to execution load from
   * @returns {Promise} Resolving to the load results report generated by Artillery
   */
  execLoad: (timeNow, script) => {
    if (script._simulation) return Promise.resolve({ Payload: '{ "errors": 0 }' })

    const scriptPath = path.resolve(os.tmpdir(), 'script.json')
    const outputPath = path.resolve(os.tmpdir(), 'output.json')

    fs.writeFileSync(scriptPath, JSON.stringify(script))

    return new Promise((resolve, reject) => {
      try {
        // Since Artillery will call process.exit() upon termination,
        // we monkey-patch it to load result and resolve/reject the Promise.
        const exit = process.exit

        process.exit = (code) => {
          process.exit = exit // Unpatch, you silly monkey!
          console.log(`Artillery exited: ${code}`)
          if (code === 0) {
            fs.readFile(outputPath, null, (err, results) => resolve(JSON.parse(results)))
          } else {
            throw new Error(`Artillery exited with code: ${code}`)
          }
        }

        console.log('Starting Artillery...')
        run(scriptPath, { output: outputPath })
      } catch (ex) {
        const msg = `ERROR exception encountered while executing load from ${script._genesis} in ${timeNow}: ${ex.message}\n${ex.stack}`
        console.error(msg)
        reject(new def.TaskError(msg))
      }
    })
  },
})

module.exports = impl

/* test-code */
module.exports.impl = impl
/* end-test-code */
